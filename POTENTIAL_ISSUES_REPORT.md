# Отчёт о возможных проблемах (дополнительный аудит)

Дата проверки: февраль 2025. Ниже — найденные риски и что уже исправлено.

---

## Исправлено в этом аудите

### 1. XSS при выводе ошибки загрузки устройств NetBox (main.js)
- **Было:** `error.message` подставлялся в `innerHTML` без экранирования. При ответе API с HTML в сообщении возможна инъекция.
- **Исправлено:** используется `escapeHtml(errMsg)`.

### 2. XSS в результатах поиска по карте (main.js)
- **Было:** `data-id="${uniqueId}"` — `uniqueId` берётся из объектов карты (пользовательские данные). Строка с кавычками могла выйти из атрибута и выполнить код.
- **Исправлено:** `data-id="${escapeHtml(String(uniqueId))}"`.

### 3. XSS в истории изменений (js/history.js)
- **Было:** В разметку подставлялись `detailsText`, `entry.actionName`, `entry.icon`, `entryDate` без экранирования. Данные из `details` (имена объектов, узлов, пользователей) могут быть заданы пользователем.
- **Исправлено:** при выводе используется `escapeHtml()` для этих полей.

---

## Рекомендации (без правок в коде)

### Безопасность

1. **API-ключ Яндекс.Карт в index.html**  
   Ключ задан в разметке в открытом виде. Лучше вынести в конфиг/переменные окружения и подставлять при сборке или через бэкенд; в кабинете разработчика ограничить ключ по доменам.

2. **Пароли**  
   Используется простой хэш (для демо). Для эксплуатации — bcrypt или argon2 (уже отмечено в POSSIBLE_ISSUES.md).

3. **CORS в server-api.js**  
   `cors({ origin: true, credentials: true })` разрешает любой origin. Для продакшена лучше явно указать список разрешённых origin.

4. **Ограничение размера тела запроса**  
   Сейчас `express.json({ limit: '10mb' })`. При необходимости можно уменьшить и добавить rate limiting для API.

### Надёжность и стиль кода

5. **Пустые `catch (e) {}`**  
   Во многих местах ошибки игнорируются. Имеет смысл хотя бы логировать в консоль или в логгер (на сервере), чтобы упростить отладку.

6. **Устаревший метод `.substr()`**  
   В проекте используется `String.prototype.substr(2, 9)` (deprecated). Рекомендуется заменить на `.slice(2, 11)` во всех файлах.

7. **Идентификаторы в onclick (main.js, список пользователей)**  
   В `onclick="approveUserRequest('${user.id}')"` и аналогичных вызовах подставляется `user.id`. Сейчас ID генерируются сервером (алфавитно-цифровые). Для дополнительной защиты от инъекций можно экранировать значение атрибута (например, через `escapeHtml(user.id)`) при формировании разметки.

### Функциональность

8. **Сессии в JSON-store (database.js)**  
   Сессии накапливаются в массиве; истёкшие не удаляются при проверке. Работоспособность не нарушается (проверка `expires_at > now`), но массив может расти. Можно периодически чистить старые записи при логине/проверке сессии.

9. **Порядок загрузки скриптов**  
   В index.html подключаются `auth.js`, затем `js/config.js`, `js/utils.js` (в т.ч. `escapeHtml`), затем `main.js` и `js/sync.js`. В main.js и history.js используется `escapeHtml` — он должен быть доступен глобально из utils.js; порядок загрузки корректен.

---

## Уже учтённое в проекте

- Экранирование пользовательских данных через `escapeHtml()` в модальных окнах объектов, опор, кабелей, списке устройств NetBox (имя, тип, местоположение).
- В updates.js при выводе ссылки на новую версию используется `escapeHtml(result.latest)` и `escapeHtml(result.url)`.
- В js/notifications.js текст уведомлений задаётся через `textContent`, не через `innerHTML` (риск XSS в тостах минимален).

---

При появлении новых сценариев использования или изменении источников данных (особенно вставка в HTML или в атрибуты) стоит проверять, что все пользовательские и внешние значения проходят через `escapeHtml()` или задаются через безопасные API (например, `textContent`).
